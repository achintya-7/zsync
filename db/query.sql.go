// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const deleteCommand = `-- name: DeleteCommand :one
DELETE FROM commands WHERE command = ? RETURNING "key", command, frequency, created_at, last_called_at
`

func (q *Queries) DeleteCommand(ctx context.Context, command string) (Command, error) {
	row := q.db.QueryRowContext(ctx, deleteCommand, command)
	var i Command
	err := row.Scan(
		&i.Key,
		&i.Command,
		&i.Frequency,
		&i.CreatedAt,
		&i.LastCalledAt,
	)
	return i, err
}

const deleteUrl = `-- name: DeleteUrl :one
DELETE FROM urls WHERE url = ? RETURNING "key", url, platform, created_at
`

func (q *Queries) DeleteUrl(ctx context.Context, url string) (Url, error) {
	row := q.db.QueryRowContext(ctx, deleteUrl, url)
	var i Url
	err := row.Scan(
		&i.Key,
		&i.Url,
		&i.Platform,
		&i.CreatedAt,
	)
	return i, err
}

const getAllCommands = `-- name: GetAllCommands :many
SELECT "key", command, frequency, created_at, last_called_at FROM commands
`

func (q *Queries) GetAllCommands(ctx context.Context) ([]Command, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Command
	for rows.Next() {
		var i Command
		if err := rows.Scan(
			&i.Key,
			&i.Command,
			&i.Frequency,
			&i.CreatedAt,
			&i.LastCalledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUrls = `-- name: GetAllUrls :many
SELECT "key", url, platform, created_at FROM urls
`

func (q *Queries) GetAllUrls(ctx context.Context) ([]Url, error) {
	rows, err := q.db.QueryContext(ctx, getAllUrls)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Url
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.Key,
			&i.Url,
			&i.Platform,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommandsByPlatform = `-- name: GetCommandsByPlatform :one
SELECT "key", url, platform, created_at FROM urls WHERE platform = ?
`

func (q *Queries) GetCommandsByPlatform(ctx context.Context, platform string) (Url, error) {
	row := q.db.QueryRowContext(ctx, getCommandsByPlatform, platform)
	var i Url
	err := row.Scan(
		&i.Key,
		&i.Url,
		&i.Platform,
		&i.CreatedAt,
	)
	return i, err
}

const getCroneSeconds = `-- name: GetCroneSeconds :one
SELECT cron_seconds FROM config LIMIT 1
`

func (q *Queries) GetCroneSeconds(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCroneSeconds)
	var cron_seconds int64
	err := row.Scan(&cron_seconds)
	return cron_seconds, err
}

const getTopCommands = `-- name: GetTopCommands :many
SELECT "key", command, frequency, created_at, last_called_at FROM commands ORDER BY frequency DESC LIMIT 10
`

func (q *Queries) GetTopCommands(ctx context.Context) ([]Command, error) {
	rows, err := q.db.QueryContext(ctx, getTopCommands)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Command
	for rows.Next() {
		var i Command
		if err := rows.Scan(
			&i.Key,
			&i.Command,
			&i.Frequency,
			&i.CreatedAt,
			&i.LastCalledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUrl = `-- name: InsertUrl :one
INSERT INTO urls (url, platform, created_at) 
VALUES (?, ?, CURRENT_TIMESTAMP) ON CONFLICT DO NOTHING
RETURNING "key", url, platform, created_at
`

type InsertUrlParams struct {
	Url      string
	Platform string
}

func (q *Queries) InsertUrl(ctx context.Context, arg InsertUrlParams) (Url, error) {
	row := q.db.QueryRowContext(ctx, insertUrl, arg.Url, arg.Platform)
	var i Url
	err := row.Scan(
		&i.Key,
		&i.Url,
		&i.Platform,
		&i.CreatedAt,
	)
	return i, err
}

const queryCommands = `-- name: QueryCommands :many
SELECT "key", command, frequency, created_at, last_called_at FROM commands WHERE command LIKE '%' || ? || '%' ORDER BY frequency DESC
`

func (q *Queries) QueryCommands(ctx context.Context, dollar_1 sql.NullString) ([]Command, error) {
	rows, err := q.db.QueryContext(ctx, queryCommands, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Command
	for rows.Next() {
		var i Command
		if err := rows.Scan(
			&i.Key,
			&i.Command,
			&i.Frequency,
			&i.CreatedAt,
			&i.LastCalledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCommand = `-- name: UpsertCommand :one
INSERT INTO commands (command, frequency, last_called_at) VALUES (?, ?, CURRENT_TIMESTAMP) 
ON CONFLICT (command) DO UPDATE SET frequency = commands.frequency + 1, last_called_at = CURRENT_TIMESTAMP
RETURNING "key", command, frequency, created_at, last_called_at
`

type UpsertCommandParams struct {
	Command   string
	Frequency int64
}

func (q *Queries) UpsertCommand(ctx context.Context, arg UpsertCommandParams) (Command, error) {
	row := q.db.QueryRowContext(ctx, upsertCommand, arg.Command, arg.Frequency)
	var i Command
	err := row.Scan(
		&i.Key,
		&i.Command,
		&i.Frequency,
		&i.CreatedAt,
		&i.LastCalledAt,
	)
	return i, err
}

const upsertConfig = `-- name: UpsertConfig :one
INSERT INTO config (cron_seconds) 
VALUES (?) ON CONFLICT DO NOTHING 
RETURNING cron_seconds
`

func (q *Queries) UpsertConfig(ctx context.Context, cronSeconds int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertConfig, cronSeconds)
	var cron_seconds int64
	err := row.Scan(&cron_seconds)
	return cron_seconds, err
}
